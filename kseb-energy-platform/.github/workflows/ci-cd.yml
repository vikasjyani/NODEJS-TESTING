# GitHub Actions Workflow for KSEB Energy Futures Platform CI/CD
name: KSEB Platform CI/CD

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*.*.*' # Trigger on version tags like v1.0.0
  pull_request:
    branches:
      - main
      - develop
  workflow_dispatch: # Allow manual triggering

env:
  NODE_VERSION: '18.x' # Specify Node.js version for consistency
  PYTHON_VERSION: '3.9' # Specify Python version
  # Define common directory for artifacts if needed across jobs
  # ARTIFACT_DIR: artifact_builds

jobs:
  #------------------------------------------------------------------------------------
  # Lint & Test Job: Runs on pushes to main/develop and all PRs to these branches
  #------------------------------------------------------------------------------------
  lint-and-test:
    name: Lint & Test Suite
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [${{ env.NODE_VERSION }}] # Use env var for Node version
        # Can add os matrix if platform-specific tests are critical: [ubuntu-latest, macos-latest, windows-latest]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: | # Cache based on root and workspace lock files
            package-lock.json
            backend/package-lock.json
            frontend/package-lock.json
            electron/package-lock.json

      - name: Install All Dependencies (Root & Workspaces)
        run: npm install --workspaces --if-present && npm install # Ensures all deps are met

      - name: Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip' # Cache pip dependencies
          cache-dependency-path: 'backend/src/python/requirements.txt' # Assuming you might add one

      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          # Install from requirements.txt if it exists, otherwise install core packages
          if [ -f backend/src/python/requirements.txt ]; then
            pip install -r backend/src/python/requirements.txt
          else
            pip install pandas numpy scikit-learn statsmodels openpyxl pypsa # Core as per Dockerfile
          fi
          # Verify key Python packages for tests (optional, test_environment.py should do this)
          python backend/src/python/test_environment.py

      - name: Run Linters (ESLint & potentially Python linters)
        run: npm run lint # Assumes root lint script lints workspaces or call workspace lints

      - name: Run All Tests (Jest for JS/TS, Pytest for Python)
        run: |
          npm test # Root test script, assumes it runs workspace tests or jest.config.js handles it
          # If Python tests are run separately:
          # (cd backend/src/python && python -m unittest discover -s ../../../tests/python -p "test_*.py" -v)
          # Or using pytest if configured:
          # pytest tests/python/
        env:
          CI: true
          NODE_ENV: test
          # Any other test-specific ENV VARS like DB connections for integration tests
          # TEST_BACKEND_PORT: 5002 # If tests need a specific port different from dev

      # Optional: Upload Test Coverage (if generated by `npm test`)
      - name: Upload Coverage Report to Codecov
        if: success() # Or always() if you want to upload even on failure
        uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }} # Store this in GitHub secrets
          # files: ./coverage/lcov.info,./frontend/coverage/lcov.info # Example paths
          # directory: ./coverage/ # Or specify directory
          # flags: unittests # Flag for Codecov UI
          fail_ci_if_error: false # Don't fail CI if Codecov upload fails
          verbose: true

  #------------------------------------------------------------------------------------
  # Build Job: Builds Electron app for multiple platforms. Runs only on tags.
  #------------------------------------------------------------------------------------
  build-electron-app:
    name: Build Electron App (${{ matrix.os }})
    if: startsWith(github.ref, 'refs/tags/v') # Only run on version tags
    needs: lint-and-test # Depends on successful linting and testing
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false # Allow other OS builds to continue if one fails
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        node-version: [${{ env.NODE_VERSION }}]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: |
            package-lock.json
            backend/package-lock.json
            frontend/package-lock.json
            electron/package-lock.json

      - name: Install All Dependencies (Root & Workspaces)
        run: npm install --workspaces --if-present && npm install

      # Python setup needed if any build steps (e.g., native Node modules) depend on it
      - name: Setup Python ${{ env.PYTHON_VERSION }} (for build tools if needed)
        if: runner.os != 'Windows' # Windows GH runners usually have Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      # Restore Python runtime cache if used (less common for this type of build)
      # - name: Cache Python runtime
      #   uses: actions/cache@v3
      #   with:
      #     path: ./python-runtime # Path where you download/extract Python runtime
      #     key: ${{ runner.os }}-python-runtime-${{ hashFiles('./scripts/setup-python-runtime.sh') }}

      # Placeholder: Download/Setup Bundled Python Runtime (if not part of repo or built elsewhere)
      # This step would involve fetching a pre-built Python distribution for each OS
      # and placing it in, e.g., `python-runtime/windows`, `python-runtime/macos`, etc.
      # For this example, we assume these directories are pre-populated or handled manually for now.
      - name: Prepare Bundled Python Placeholder
        run: |
          mkdir -p python-runtime/${{ runner.os }}
          echo "Placeholder for Python runtime for ${{ runner.os }}" > python-runtime/${{ runner.os }}/python_placeholder.txt
        shell: bash


      - name: Build All Sub-Packages (Frontend, Backend, Electron Main/Preload)
        run: npm run build # This should trigger `npm run build` in all workspaces and root

      - name: Package Electron Application for ${{ matrix.os }}
        # electron-builder uses GH_TOKEN for auto-updates and releases if configured
        # CSC_LINK and CSC_KEY_PASSWORD are for code signing (Windows and macOS)
        # APPLE_ID, APPLE_ID_PASSWORD, APPLE_TEAM_ID for macOS notarization
        run: npm run dist # This uses electron-builder via root package.json script
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # --- macOS Codesign & Notarization ---
          # These secrets need to be configured in your GitHub repository settings
          # Ensure your Apple Developer account is set up for notarization.
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }} # Your Apple Developer Team ID
          # --- Windows Codesign ---
          # CSC_LINK: Path or URL to your .pfx certificate file or base64 encoded string
          # CSC_KEY_PASSWORD: Password for your .pfx certificate file
          CSC_LINK: ${{ secrets.WINDOWS_CSC_LINK }}
          CSC_KEY_PASSWORD: ${{ secrets.WINDOWS_CSC_KEY_PASSWORD }}
          # WIN_CSC_LINK, WIN_CSC_KEY_PASSWORD can also be used by electron-builder

      - name: List Output Artifacts
        run: ls -R dist/packages # Show what was built

      - name: Upload Electron App Artifact (${{ matrix.os }})
        uses: actions/upload-artifact@v3 # v3 is fine, v4 is latest
        with:
          name: KSEB-Platform-${{ matrix.os }}-${{ github.ref_name }} # Include tag name
          path: |
            dist/packages/*.dmg
            dist/packages/*.pkg
            dist/packages/*.exe
            dist/packages/*.msi
            dist/packages/*.AppImage
            dist/packages/*.snap
            dist/packages/*.deb
            dist/packages/*.rpm
            dist/packages/*.zip
            dist/packages/*.tar.gz
            dist/packages/*-portable.*
            dist/packages/latest*.yml # For auto-updater metadata
            dist/packages/builder-debug.yml
            !dist/packages/*-unpacked/ # Exclude unpacked build directories

  #------------------------------------------------------------------------------------
  # Create GitHub Release Job: Runs only on tags, after all builds are successful.
  #------------------------------------------------------------------------------------
  create-github-release:
    name: Create GitHub Release
    if: startsWith(github.ref, 'refs/tags/v')
    needs: build-electron-app # Depends on all OS builds completing
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed to create releases and upload assets

    steps:
      - name: Download All Build Artifacts
        uses: actions/download-artifact@v3 # v3 is fine
        with:
          path: dist-all-os # Download all artifacts to this directory
          # Name pattern can be used if artifacts are named consistently like KSEB-Platform-*
          # name: KSEB-Platform-* # This might not work as expected for multiple artifacts with different OS names.
          # It's often simpler to let it download all if they are uploaded with distinct names per OS job.

      - name: List Downloaded Artifacts
        run: ls -R dist-all-os # Verify artifacts are downloaded correctly

      - name: Create/Update GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          # The GITHUB_REF variable contains the tag name, e.g., refs/tags/v1.0.0
          # We can extract the tag name from it.
          tag_name: ${{ github.ref_name }}
          name: Release ${{ github.ref_name }}
          body_path: CHANGELOG.md # Or generate release notes, or leave empty for manual notes
          draft: false # Set to false to publish immediately, true to create a draft
          prerelease: ${{ contains(github.ref_name, '-beta') || contains(github.ref_name, '-alpha') }}
          files: | # Path to all artifacts from all OS builds
            dist-all-os/**/*.dmg
            dist-all-os/**/*.pkg
            dist-all-os/**/*.exe
            dist-all-os/**/*.msi
            dist-all-os/**/*.AppImage
            dist-all-os/**/*.snap
            dist-all-os/**/*.deb
            dist-all-os/**/*.rpm
            dist-all-os/**/*.zip
            dist-all-os/**/*.tar.gz
            dist-all-os/**/*-portable.*
            dist-all-os/**/latest*.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  #------------------------------------------------------------------------------------
  # Optional: Docker Build and Push Job (if deploying backend/app as Docker container)
  #------------------------------------------------------------------------------------
  # build-and-push-docker:
  #   name: Build & Push Docker Image
  #   if: github.ref == 'refs/heads/main' # Example: Only on push to main
  #   needs: lint-and-test
  #   runs-on: ubuntu-latest
  #   permissions:
  // PGPAGE_WELCOME
// License page (optional - if you have a license.txt in build resources)
// !define MUI_LICENSEPAGE_CHECKBOX
// !insertmacro MUI_PAGE_LICENSE "path\to\license.txt"
// Components page (if you have optional components)
// !insertmacro MUI_PAGE_COMPONENTS
// Directory page (installation path)
!insertmacro MUI_PAGE_DIRECTORY

// Custom Page for Python Path Configuration (Optional - advanced)
// Page custom nsPythonPage nsPythonPageLeave "Python Configuration"

// InstFiles page (shows installation progress)
!insertmacro MUI_PAGE_INSTFILES
// Finish page
!define MUI_FINISHPAGE_RUN "$INSTDIR\${APP_PRODUCT_FILENAME}.exe" ; APP_PRODUCT_FILENAME is set by electron-builder
!define MUI_FINISHPAGE_SHOWREADME "$INSTDIR\README.md" ; If you want to show a README
!define MUI_FINISHPAGE_LINK "KSEB Energy Futures Platform Website"
!define MUI_FINISHPAGE_LINK_LOCATION "https://www.kseb.in/" ; Placeholder
!insertmacro MUI_PAGE_FINISH

// Uninstaller pages
!insertmacro MUI_UNPAGE_CONFIRM
!insertmacro MUI_UNPAGE_INSTFILES

//--------------------------------
// Language

!insertmacro MUI_LANGUAGE "English"

//--------------------------------
// Installer Sections & Functions

Function .onInit
  ; Set the installation scope (per-user or per-machine)
  ; electron-builder typically handles this with nsis.perMachine option
  ; If perMachine is true: SetShellVarContext all
  ; Else: SetShellVarContext current

  ; Check for existing Python (example - this is complex and might be better handled post-install by the app)
  ; Call CheckPython
FunctionEnd

// Custom Page function example (if used)
// Function nsPythonPage
//   !insertmacro MUI_HEADER_TEXT "Python Configuration" "Configure Python settings for the application."
//   ; Add custom UI elements here using nsDialogs or InstallOptions
//   nsDialogs::Create 1018
//   Pop $0 ; HWND
//   ; ...
//   nsDialogs::Show
// FunctionEnd
// Function nsPythonPageLeave
//   ; Read values from custom page
// FunctionEnd


Section "InstallApplication" SecCore
  SectionIn RO ; Required section

  SetOutPath "$INSTDIR"
  ; Files are automatically copied by electron-builder based on "files" and "extraResources" in package.json
  ; This section is mainly for custom NSIS logic like shortcuts, registry entries.

  ; Create Desktop Shortcut (electron-builder nsis.createDesktopShortcut handles this by default)
  ; If custom logic needed: CreateShortCut "$DESKTOP\${APP_PRODUCT_NAME}.lnk" "$INSTDIR\${APP_PRODUCT_FILENAME}.exe"

  ; Create Start Menu Shortcut (electron-builder nsis.createStartMenuShortcut and nsis.menuCategory handle this)
  ; If custom logic needed:
  ; CreateDirectory "$SMPROGRAMS\${MUI_STARTMENUPAGE_FOLDER}"
  ; CreateShortCut "$SMPROGRAMS\${MUI_STARTMENUPAGE_FOLDER}\${APP_PRODUCT_NAME}.lnk" "$INSTDIR\${APP_PRODUCT_FILENAME}.exe"

  ; Write the uninstaller
  WriteUninstaller "$INSTDIR\Uninstall.exe"

  ; Register application for Add/Remove Programs
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "DisplayName" "${APP_PRODUCT_NAME}"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "UninstallString" "$INSTDIR\Uninstall.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "DisplayIcon" "$INSTDIR\${APP_PRODUCT_FILENAME}.exe,0"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "DisplayVersion" "${APP_VERSION}"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "Publisher" "${APP_AUTHOR_NAME}" ; APP_AUTHOR_NAME set if author is object
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "NoModify" 1
  WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}" "NoRepair" 1

  ; File Associations (Example for .ksep project files)
  ; Ensure APP_ID is unique and suitable for use as a ProgID base
  WriteRegStr HKCR ".ksep" "" "${APP_ID}.ksepfile"
  WriteRegStr HKCR "${APP_ID}.ksepfile" "" "KSEB Energy Project File"
  WriteRegStr HKCR "${APP_ID}.ksepfile\DefaultIcon" "" "$INSTDIR\${APP_PRODUCT_FILENAME}.exe,0" ; Use app icon
  WriteRegStr HKCR "${APP_ID}.ksepfile\shell\open\command" "" '"$INSTDIR\${APP_PRODUCT_FILENAME}.exe" "%1"'

  ; Notify Shell of changes for file associations
  System::Call 'shell32::SHChangeNotify(i 0x8000000, i 0, i 0, i 0)'

SectionEnd


; Optional Section for Bundled Python Runtime (if not handled by simply copying via extraResources)
; This section assumes Python runtime is copied to $INSTDIR\python by electron-builder
Section "Python Runtime Configuration" SecPython
    SetOutPath "$INSTDIR\python" ; This path should match where Python is bundled
    ; If specific PATH modifications are needed system-wide (requires admin, generally not recommended for user-specific installs)
    ; Or, the application itself should be configured to find this Python version.

    ; Example: Add Python to user's PATH (if user selected this option on a custom page)
    ; ${If} $AddToPathUserChoice == 1
    ;   EnVar::SetUserVar "PATH" "$INSTDIR\python;$INSTDIR\python\Scripts;%PATH%"
    ; ${EndIf}

    ; Create a batch file or script that sets up the environment for the app if needed
    ; FileOpen $0 "$INSTDIR\launch-with-python-env.bat" w
    //           token: ${{ secrets.CODECOV_TOKEN }} # If using Codecov
      #   directory: ./coverage/ # Path to coverage results

  build-and-release:
    name: Build & Release Electron App
    if: startsWith(github.ref, 'refs/tags/v') # Only run on version tags
    needs: lint-test # Ensure linting and tests pass before building
    runs-on: ${{ matrix.os }} # Build on multiple OS

    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        node-version: [18.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies (root and workspaces)
        run: npm install --workspaces --if-present && npm install

      # For macOS and Linux, ensure Python is available for potential native module builds or scripts
      # Windows runners usually have Python.
      - name: Setup Python (macOS & Linux)
        if: runner.os == 'macOS' || runner.os == 'Linux'
        uses: actions/setup-python@v4
        with:
          python-version: '3.9' # Or your target Python version for scripts

      - name: Build all packages (frontend, backend, electron main/preload)
        run: npm run build # This should trigger workspace builds as defined in root package.json

      - name: Package Electron application
        run: npm run dist # This should use electron-builder to create installers/packages
        env:
          # For code signing (macOS and Windows) - set these as encrypted secrets in GitHub repo settings
          CSC_LINK: ${{ secrets.CSC_LINK }} # Certificate link or base64 encoded cert
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }} # Certificate password
          # For notarization on macOS (if needed)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # For GitHub releases
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Automatically available

      - name: Upload Artifacts (Installers/Packages)
        uses: actions/upload-artifact@v3
        with:
          name: KSEB-Energy-Platform-${{ matrix.os }}
          path: | # Paths to the distributable files
            dist/packages/*.dmg
            dist/packages/*.exe
            dist/packages/*.AppImage
            dist/packages/*.deb
            dist/packages/*.rpm
            dist/packages/*.zip
            dist/packages/*.tar.gz
            dist/packages/latest*.yml # For auto-updater
            !dist/packages/*-unpacked/ # Exclude unpacked directories

      # Optional: Create a GitHub Release
      - name: Create GitHub Release
        if: success() && startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        with:
          # tag_name: ${{ github.ref_name }} # Use the tag that triggered the workflow
          # name: Release ${{ github.ref_name }}
          body: |
            Release of version ${{ github.ref_name }}.
            See CHANGELOG.md for details.

            **Artifacts:**
            (Links will be automatically added by uploading to the release)
          draft: true # Create as a draft, manually publish later
          prerelease: contains(github.ref, '-beta') || contains(github.ref, '-alpha') # Mark as pre-release if tag contains -beta or -alpha
          files: | # Attach all built packages to the release
            dist/packages/*.dmg
            dist/packages/*.exe
            dist/packages/*.AppImage
            dist/packages/*.deb
            dist/packages/*.rpm
            dist/packages/*.zip
            dist/packages/*.tar.gz
            dist/packages/latest*.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
//     FileWrite $0 "@echo off$\r$\n"
//     FileWrite $0 "set PATH=$INSTDIR\python;$INSTDIR\python\Scripts;%PATH%$\r$\n"
//     FileWrite $0 'start "" "$INSTDIR\${APP_PRODUCT_FILENAME}.exe"$\r$\n'
//     FileClose $0
SectionEnd


;--------------------------------
; Uninstaller Section

Section "Uninstall"
  ; Remove files and directories
  RMDir /r "$INSTDIR" ; This removes everything including the uninstaller itself if it's in $INSTDIR

  ; Remove shortcuts
  Delete "$DESKTOP\${APP_PRODUCT_NAME}.lnk"
  Delete "$SMPROGRAMS\${MUI_STARTMENUPAGE_FOLDER}\${APP_PRODUCT_NAME}.lnk"
  RMDir "$SMPROGRAMS\${MUI_STARTMENUPAGE_FOLDER}" ; Remove folder if empty

  ; Remove registry keys
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APP_ID}"
  DeleteRegKey HKCR ".ksep"
  DeleteRegKey HKCR "${APP_ID}.ksepfile"

  ; Notify Shell of changes
  System::Call 'shell32::SHChangeNotify(i 0x8000000, i 0, i 0, i 0)'
SectionEnd

;--------------------------------
; Helper Functions (Examples)

; Function CheckPython
//           token: ${{ secrets.CODECOV_TOKEN }} # If using Codecov
      #   directory: ./coverage/ # Path to coverage results

  build-and-release:
    name: Build & Release Electron App
    if: startsWith(github.ref, 'refs/tags/v') # Only run on version tags
    needs: lint-test # Ensure linting and tests pass before building
    runs-on: ${{ matrix.os }} # Build on multiple OS

    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]
        node-version: [18.x]

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies (root and workspaces)
        run: npm install --workspaces --if-present && npm install

      # For macOS and Linux, ensure Python is available for potential native module builds or scripts
      # Windows runners usually have Python.
      - name: Setup Python (macOS & Linux)
        if: runner.os == 'macOS' || runner.os == 'Linux'
        uses: actions/setup-python@v4
        with:
          python-version: '3.9' # Or your target Python version for scripts

      - name: Build all packages (frontend, backend, electron main/preload)
        run: npm run build # This should trigger workspace builds as defined in root package.json

      - name: Package Electron application
        run: npm run dist # This should use electron-builder to create installers/packages
        env:
          # For code signing (macOS and Windows) - set these as encrypted secrets in GitHub repo settings
          CSC_LINK: ${{ secrets.CSC_LINK }} # Certificate link or base64 encoded cert
          CSC_KEY_PASSWORD: ${{ secrets.CSC_KEY_PASSWORD }} # Certificate password
          # For notarization on macOS (if needed)
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          # For GitHub releases
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Automatically available

      - name: Upload Artifacts (Installers/Packages)
        uses: actions/upload-artifact@v3
        with:
          name: KSEB-Energy-Platform-${{ matrix.os }}
          path: | # Paths to the distributable files
            dist/packages/*.dmg
            dist/packages/*.exe
            dist/packages/*.AppImage
            dist/packages/*.deb
            dist/packages/*.rpm
            dist/packages/*.zip
            dist/packages/*.tar.gz
            dist/packages/latest*.yml # For auto-updater
            !dist/packages/*-unpacked/ # Exclude unpacked directories

      # Optional: Create a GitHub Release
      - name: Create GitHub Release
        if: success() && startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v1
        with:
          # tag_name: ${{ github.ref_name }} # Use the tag that triggered the workflow
          # name: Release ${{ github.ref_name }}
          body: |
            Release of version ${{ github.ref_name }}.
            See CHANGELOG.md for details.

            **Artifacts:**
            (Links will be automatically added by uploading to the release)
          draft: true # Create as a draft, manually publish later
          prerelease: contains(github.ref, '-beta') || contains(github.ref, '-alpha') # Mark as pre-release if tag contains -beta or -alpha
          files: | # Attach all built packages to the release
            dist/packages/*.dmg
            dist/packages/*.exe
            dist/packages/*.AppImage
            dist/packages/*.deb
            dist/packages/*.rpm
            dist/packages/*.zip
            dist/packages/*.tar.gz
            dist/packages/latest*.yml
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
// ;   ; This is a complex task. A simple check:
// ;   ClearErrors
// ;   ExecWait '"python" --version' $0
// ;   IfErrors PathNotFound NoPython
// ;   StrCpy $PythonExe "python"
// ;   Goto PythonFound
// ; PathNotFound:
// ;   ClearErrors
// ;   ExecWait '"python3" --version' $0
// ;   IfErrors NoPython
// ;   StrCpy $PythonExe "python3"
// ;   Goto PythonFound
// ; NoPython:
// ;   MessageBox MB_OK|MB_ICONINFORMATION "Python does not seem to be installed or not in PATH. The application might bundle its own Python or prompt you later."
// ;   StrCpy $PythonExe ""
// ; PythonFound:
// ;   ; $PythonExe now holds 'python' or 'python3' if found in PATH
// ;   ; The application should ideally use its bundled Python.
// ; FunctionEnd

// ; Function AddToPath
// ;   Push $0
// ;   Push $1
// ;   Push $2
// ;   ; $R0: Path to add
// ;   ; $R1: Current User (1) or All Users (0)
// ;   ClearErrors
// ;   ${If} $R1 == 1 ; Current User
// ;     ReadRegStr $0 HKCU "Environment" "Path"
// ;     StrCpy $1 "$R0;$0"
// ;     WriteRegExpandStr HKCU "Environment" "Path" $1
// ;   ${Else} ; All Users (requires Admin)
// ;     ReadRegStr $0 HKLM "SYSTEM\CurrentControlSet\Control\Session Manager\Environment" "Path"
// ;     StrCpy $1 "$R0;$0"
// ;     WriteRegExpandStr HKLM "SYSTEM\CurrentControlSet\Control\Session Manager\Environment" "Path" $1
// ;   ${EndIf}
// ;   SendMessage ${HWND_BROADCAST} ${WM_SETTINGCHANGE} 0 "STR:Environment" /TIMEOUT=5000
// ;   Pop $2
// ;   Pop $1
// ;   Pop $0
// ; FunctionEnd

// ; Descriptions for sections (if using components page)
// ; !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
// ;  !insertmacro MUI_DESCRIPTION_TEXT ${SecCore} "Installs the main application files."
// ;  !insertmacro MUI_DESCRIPTION_TEXT ${SecPython} "Configures the bundled Python runtime environment (if applicable)."
// ; !insertmacro MUI_FUNCTION_DESCRIPTION_END
//   #     contents: read
  #     packages: write # Needed to push to GitHub Container Registry (ghcr.io)
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3
  #
  #     - name: Log in to GitHub Container Registry
  #       uses: docker/login-action@v3
  #       with:
  #         registry: ghcr.io
  #         username: ${{ github.actor }}
  #         password: ${{ secrets.GITHUB_TOKEN }}
  #
  #     - name: Build and push Docker image
  #       uses: docker/build-push-action@v5
  #       with:
  #         context: . # Root of the repository, where Dockerfile is
  #         file: ./Dockerfile # Explicitly specify Dockerfile
  #         push: true
  #         tags: | # Example tags
  #           ghcr.io/${{ github.repository_owner }}/kseb-energy-platform:${{ github.sha }}
  #           ghcr.io/${{ github.repository_owner }}/kseb-energy-platform:latest
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max

# Note: For the `build-electron-app` job to correctly bundle Python, you'll need to ensure
# the `python-runtime/{os}` directories are populated with the respective Python distributions
# before electron-builder runs. This might involve a separate script or manual setup for now.
# The `extraResources` in `package.json` (build section) points to these.
```
